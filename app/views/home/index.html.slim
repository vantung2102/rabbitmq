- provide(:title, "RabbitMQ")

= render 'introduction'
= render 'agenda'
= render 'problem'
= render 'solution'

section.py-20.bg-base-100
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | üì¨ What is Message Queue?

    .bg-gradient-to-r.from-purple-100.to-purple-200.text-gray-800.p-8.rounded-2xl.mb-10.border-l-6.border-purple-600.shadow-xl
      p.text-xl.leading-relaxed.m-0.font-semibold
        strong.text-purple-700 Definition:
        |  Message Queue is a queuing system that stores messages/jobs for later processing, decoupling task creation (producer) from execution (consumer).

    .bg-white.p-12.rounded-2xl.border-2.border-gray-300.mb-10.shadow-2xl
      h3.text-center.mb-10.text-3xl.font-black.text-gray-800 3 Main Components:
      .flex.items-center.justify-between.flex-wrap.gap-6.mb-8
        .text-center.flex-1.min-w-32
          .w-32.h-32.bg-gradient-to-br.from-orange-500.to-orange-600.rounded-3xl.flex.items-center.justify-center.text-6xl.mx-auto.mb-4.shadow-2xl.hover:scale-110.transition-transform.duration-300 üì§
          .font-black.text-xl.mb-2.text-gray-800 Producer
          .text-sm.text-gray-600.font-medium (Rails App)
        .text-5xl.text-orange-500.font-bold ‚Üí
        .text-center.flex-1.min-w-32
          .w-32.h-32.bg-gradient-to-br.from-orange-500.to-orange-600.rounded-3xl.flex.items-center.justify-center.text-6xl.mx-auto.mb-4.shadow-2xl.hover:scale-110.transition-transform.duration-300 üì¨
          .font-black.text-xl.mb-2.text-gray-800 Queue
          .text-sm.text-gray-600.font-medium (Storage)
        .text-5xl.text-orange-500.font-bold ‚Üí
        .text-center.flex-1.min-w-32
          .w-32.h-32.bg-gradient-to-br.from-orange-500.to-orange-600.rounded-3xl.flex.items-center.justify-center.text-6xl.mx-auto.mb-4.shadow-2xl.hover:scale-110.transition-transform.duration-300 ‚öôÔ∏è
          .font-black.text-xl.mb-2.text-gray-800 Consumer
          .text-sm.text-gray-600.font-medium (Worker)

      .bg-gradient-to-br.from-blue-50.to-indigo-50.p-8.rounded-xl.mt-10.shadow-xl.border-2.border-blue-300
        h4.text-2xl.font-black.mb-6.text-center.text-blue-700 Message Flow:
        .space-y-4
          .flex.items-center.gap-4
            .w-12.h-12.bg-gradient-to-br.from-blue-500.to-blue-600.text-white.rounded-full.flex.items-center.justify-center.font-black.text-lg.shadow-lg 1
            span.text-lg.font-semibold.text-gray-800 1. Producer sends job
          .text-center.text-blue-500.text-3xl.mb-2 ‚¨áÔ∏è
          .flex.items-center.gap-4
            .w-12.h-12.bg-gradient-to-br.from-blue-500.to-blue-600.text-white.rounded-full.flex.items-center.justify-center.font-black.text-lg.shadow-lg 2
            span.text-lg.font-semibold.text-gray-800 2. Queue stores message
          .text-center.text-blue-500.text-3xl.mb-2 ‚¨áÔ∏è
          .flex.items-center.gap-4
            .w-12.h-12.bg-gradient-to-br.from-blue-500.to-blue-600.text-white.rounded-full.flex.items-center.justify-center.font-black.text-lg.shadow-lg 3
            span.text-lg.font-semibold.text-gray-800 3. Consumer fetches job
          .text-center.text-blue-500.text-3xl.mb-2 ‚¨áÔ∏è
          .flex.items-center.gap-4
            .w-12.h-12.bg-gradient-to-br.from-blue-500.to-blue-600.text-white.rounded-full.flex.items-center.justify-center.font-black.text-lg.shadow-lg 4
            span.text-lg.font-semibold.text-gray-800 4. Consumer processes
          .text-center.text-blue-500.text-3xl.mb-2 ‚¨áÔ∏è
          .flex.items-center.gap-4
            .w-12.h-12.bg-gradient-to-br.from-blue-500.to-blue-600.text-white.rounded-full.flex.items-center.justify-center.font-black.text-lg.shadow-lg 5
            span.text-lg.font-semibold.text-gray-800 5. Consumer acknowledges

    .grid.grid-cols-1.sm:grid-cols-2.lg:grid-cols-4.gap-6
      - features = [{ title: "FIFO", desc: "First In First Out" }, { title: "Asynchronous", desc: "Producer doesn't wait" }, { title: "Decoupling", desc: "Independent components" }, { title: "Scalable", desc: "Add multiple consumers" }]
      - features.each do |feature|
        .bg-gradient-to-br.from-teal-50.to-blue-50.p-6.rounded-xl.border-l-4.border-teal-500.shadow-lg.hover:shadow-xl.transition-shadow
          .font-black.text-xl.mb-2.text-gray-800 = feature[:title]
          .text-sm.text-gray-600.font-medium = feature[:desc]

section.py-20.bg-gradient-to-b.from-base-200.to-base-100
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | üìÆ What is Message Broker?

    .bg-gradient-to-r.from-purple-100.to-purple-200.text-gray-800.p-8.rounded-2xl.mb-10.border-l-6.border-purple-600.shadow-xl
      p.text-2xl.leading-relaxed.mb-3.font-black.text-purple-800
        | Message Broker = "Smart Post Office"
      p.text-lg.m-0.font-semibold
        | Middleware between Producer and Consumer, ensuring messages are: Received ‚Üí Routed ‚Üí Stored ‚Üí Delivered ‚Üí Guaranteed

    .grid.grid-cols-1.md:grid-cols-2.gap-8.mb-8
      .bg-white.p-10.rounded-2xl.border-2.border-gray-300.shadow-2xl
        h3.text-3xl.mb-6.border-b-4.border-orange-500.pb-4.font-black.text-gray-800 Comparison
        ul.list-none.p-0.space-y-4
          li.py-3.px-4.bg-orange-50.rounded-lg
            strong.text-orange-700.font-bold Message Queue:
            span.text-gray-700.ml-2  Data structure (queue)
          li.py-3.px-4.bg-orange-50.rounded-lg
            strong.text-orange-700.font-bold Message Broker:
            span.text-gray-700.ml-2  Complete system (queues + routing + persistence)

      .bg-white.p-10.rounded-2xl.border-2.border-gray-300.shadow-2xl
        h3.text-3xl.mb-6.border-b-4.border-orange-500.pb-4.font-black.text-gray-800 Popular Brokers
        ul.list-none.p-0.space-y-4
          li.py-3.px-4.bg-purple-50.rounded-lg.text-lg.font-medium
            span.text-2xl.mr-3 üêá
            strong.text-purple-700 RabbitMQ
            span.text-gray-700.ml-2  - AMQP, feature-rich (Today's focus)
          li.py-3.px-4.bg-red-50.rounded-lg.text-lg.font-medium
            span.text-2xl.mr-3 üíæ
            strong.text-red-700 Redis
            span.text-gray-700.ml-2  - In-memory, simple, fast
          li.py-3.px-4.bg-blue-50.rounded-lg.text-lg.font-medium
            span.text-2xl.mr-3 ‚òï
            strong.text-blue-700 Kafka
            span.text-gray-700.ml-2  - High throughput, streaming

section.py-20.bg-gradient-to-b.from-base-100.to-base-200
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | üêá RabbitMQ Overview

    .text-center.text-9xl.mb-10.animate-pulse üê∞

    .grid.grid-cols-1.md:grid-cols-2.gap-8.mb-10
      .bg-white.p-10.rounded-2xl.border-2.border-orange-300.shadow-2xl
        h3.text-3xl.mb-6.border-b-4.border-orange-500.pb-4.font-black.text-gray-800 What is RabbitMQ?
        ul.list-none.p-0.space-y-3
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium ‚úÖ Open-source Message Broker, follows AMQP protocol
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium ‚úÖ Written in Erlang ‚Üí Highly concurrent, fault-tolerant
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium ‚úÖ Enterprise-grade: Reliability, scalability, flexibility
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium ‚úÖ Mature ecosystem (15+ years)

      .bg-white.p-10.rounded-2xl.border-2.border-orange-300.shadow-2xl
        h3.text-3xl.mb-6.border-b-4.border-orange-500.pb-4.font-black.text-gray-800 Why Choose RabbitMQ?
        ul.list-none.p-0.space-y-3
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium ‚úÖ Guaranteed message delivery
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium ‚úÖ Flexible routing (4 exchange types)
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium ‚úÖ Clustering & High Availability
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium ‚úÖ Management UI + Monitoring
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium ‚úÖ Multi-language support

    .bg-gradient-to-r.from-purple-100.to-purple-200.text-gray-800.p-8.rounded-2xl.border-l-4.border-teal-500.mt-10.shadow-xl
      p.mb-4.font-black.text-2xl.text-purple-800 Key Differentiators:
      .grid.grid-cols-2.md:grid-cols-5.gap-4.text-base
        - differentiators = ["Complex routing patterns", "Publisher confirms", "Dead letter exchanges", "Message TTL", "Priority queues"]
        - differentiators.each do |diff|
          span.bg-white.px-4.py-2.rounded-lg.shadow-sm.font-medium ‚Ä¢ #{diff}

section.py-20.bg-gradient-to-b.from-base-200.to-base-100
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | üèóÔ∏è RabbitMQ Architecture & Components

    .bg-white.p-12.rounded-2xl.border-2.border-gray-300.mb-10.shadow-2xl
      h3.text-center.mb-10.text-3xl.font-black.text-gray-800 Architecture Flow:
      .flex.items-center.justify-between.flex-wrap.gap-4.mb-8
        - arch_components = [{ icon: "üì§", name: "Producer" }, { icon: "üîå", name: "Connection" }, { icon: "üì°", name: "Channel" }, { icon: "üîÄ", name: "Exchange" }, { icon: "üîó", name: "Binding" }, { icon: "üì¨", name: "Queue" }, { icon: "‚öôÔ∏è", name: "Consumer" }]
        - arch_components.each_with_index do |comp, index|
          .text-center.flex-1.min-w-24
            .w-18.h-18.bg-gradient-to-br.from-orange-500.to-orange-600.rounded-xl.flex.items-center.justify-center.text-4xl.mx-auto.mb-3 = comp[:icon]
            .font-semibold.text-sm = comp[:name]
          - unless index == arch_components.length - 1
            .text-4xl.text-orange-500 ‚Üí

    .bg-white.rounded-2xl.overflow-hidden.mb-10.shadow-2xl
      .grid.grid-cols-3.gap-6.p-6.bg-gradient-to-r.from-orange-500.to-orange-600.font-black.text-white.text-lg
        div Component
        div Role
        div Importance

      - arch_details = [{ component: "Connection", role: "TCP connection between app and RabbitMQ", importance: "1 app = 1 connection, expensive" }, { component: "Channel", role: "Virtual connection within Connection", importance: "Lightweight, multiple channels/connection" }, { component: "Exchange", role: "Routes messages to queues", importance: "Core routing logic" }, { component: "Binding", role: "Rules linking Exchange ‚Üí Queue", importance: "Defines routing patterns" }, { component: "Queue", role: "Buffer storing messages for consumer", importance: "FIFO storage" }, { component: "Routing Key", role: "Key for routing message", importance: "Pattern matching" }]
      - arch_details.each do |detail|
        .grid.grid-cols-3.gap-6.p-6.border-b.border-gray-200.hover:bg-gray-50.transition-colors
          div
            strong.font-bold.text-lg.text-gray-800 = detail[:component]
          div.text-gray-700 = detail[:role]
          div.text-gray-600 = detail[:importance]

    .bg-gradient-to-br.from-blue-50.to-indigo-50.border-2.border-blue-500.p-8.rounded-2xl.shadow-xl
      h4.font-black.text-2xl.text-blue-700.mb-4 Why need Exchange?
      .grid.grid-cols-1.md:grid-cols-2.gap-4.text-base
        - exchange_reasons = ["Decoupling: Producer doesn't know which queue processes", "Flexibility: Change routing without modifying code", "Broadcast: 1 message ‚Üí multiple queues", "Filtering: Conditional routing"]
        - exchange_reasons.each do |reason|
          span.bg-white.px-5.py-3.rounded-lg.shadow-sm.font-medium.text-gray-700 ‚úÖ #{reason}

section.py-20.bg-gradient-to-b.from-base-100.to-base-200
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | üîÄ RabbitMQ Exchange Types

    .bg-white.rounded-2xl.p-10.mb-10.border-2.border-blue-500.shadow-2xl.hover:shadow-3xl.transition-shadow
      h3.text-3xl.font-bold.mb-4.text-blue-600
        | 1. Direct Exchange
      .grid.grid-cols-1.md:grid-cols-2.gap-6.mb-6
        div
          p.text-lg.mb-4
            strong Mechanism:
            |  Exact match routing key
          .bg-white.p-4.rounded-lg.mb-4
            p.font-mono.text-sm.mb-2 Message with routing_key = "order.payment"
            p.text-gray-600.text-sm ‚Üì
            p.font-mono.text-sm.mb-2 Exchange checks bindings
            p.text-gray-600.text-sm ‚Üì
            p.font-mono.text-sm Queue with binding key = "order.payment" receives message
          p.font-bold.mb-2 ‚úÖ Advantages:
          ul.list-disc.list-inside.text-sm.mb-2
            li Simple, easy to understand
            li High performance (exact match)
            li Suitable for simple routing
          p.font-bold.mb-2 ‚ùå Disadvantages:
          ul.list-disc.list-inside.text-sm.mb-2
            li Not flexible
            li Must know exact queue name
            li Hard to maintain when scaling
        div
          p.font-bold.mb-2 üéØ When to use:
          ul.list-disc.list-inside.text-sm.mb-4
            li Priority queues (high, medium, low)
            li Task distribution by type
            li Simple 1-to-1 routing
          .bg-blue-50.p-4.rounded-lg
            p.font-bold.mb-2 Real example:
            p.text-sm Logs system:
            p.font-mono.text-xs.mt-2 "error" ‚Üí error_queue
            p.font-mono.text-xs "warning" ‚Üí warning_queue
            p.font-mono.text-xs "info" ‚Üí info_queue

    .bg-white.rounded-2xl.p-10.mb-10.border-2.border-green-500.shadow-2xl.hover:shadow-3xl.transition-shadow
      h3.text-3xl.font-bold.mb-4.text-green-600
        | 2. Fanout Exchange
      .grid.grid-cols-1.md:grid-cols-2.gap-6.mb-6
        div
          p.text-lg.mb-4
            strong Mechanism:
            |  Broadcast to ALL bound queues (ignore routing key)
          .bg-white.p-4.rounded-lg.mb-4
            p.font-mono.text-sm.mb-2 Message arrives at Exchange
            p.text-gray-600.text-sm ‚Üì
            p.font-mono.text-sm.mb-2 Broadcast to ALL bound queues
            p.text-gray-600.text-sm ‚Üì
            p.font-mono.text-sm Ignore routing key
          p.font-bold.mb-2 ‚úÖ Advantages:
          ul.list-disc.list-inside.text-sm.mb-2
            li Efficient broadcasting
            li Easy to add consumers
            li Perfect pub/sub pattern
          p.font-bold.mb-2 ‚ùå Disadvantages:
          ul.list-disc.list-inside.text-sm.mb-2
            li No filtering
            li All queues receive message (can be wasteful)
            li Cannot control destination
        div
          p.font-bold.mb-2 üéØ When to use:
          ul.list-disc.list-inside.text-sm.mb-4
            li Logging system (all services need logs)
            li Cache invalidation (clear cache on all nodes)
            li Real-time notifications (broadcast to all users)
            li Event broadcasting
          .bg-green-50.p-4.rounded-lg
            p.font-bold.mb-2 Real example:
            p.text-sm User registered event:
            p.font-mono.text-xs.mt-2 ‚Üí Email service (send welcome)
            p.font-mono.text-xs ‚Üí Analytics service (track)
            p.font-mono.text-xs ‚Üí CRM service (add to pipeline)
            p.font-mono.text-xs ‚Üí Notification service (push notification)

    .bg-gradient-to-br.from-orange-50.to-yellow-50.rounded-2xl.p-10.mb-10.border-4.border-orange-500.shadow-2xl.hover:shadow-3xl.transition-shadow.relative
      .absolute.-top-5.left-8.bg-gradient-to-r.from-orange-500.to-orange-600.text-white.px-6.py-2.rounded-full.font-black.text-base.shadow-xl ‚≠ê MOST POWERFUL
      h3.text-3xl.font-bold.mb-4.text-orange-600
        | 3. Topic Exchange ‚≠ê
      .grid.grid-cols-1.md:grid-cols-2.gap-6.mb-6
        div
          p.text-lg.mb-4
            strong Mechanism:
            |  Pattern matching with wildcards
          .bg-white.p-4.rounded-lg.mb-4
            p.font-bold.text-sm.mb-2 Wildcards:
            p.font-mono.text-xs.mb-1
              | * = match exactly 1 word
            p.font-mono.text-xs
              | # = match 0 or more words
            p.text-gray-600.text-sm.mt-4.mb-2 Example:
            p.font-mono.text-xs Messages: "order.created.vn", "order.paid.us"
            p.font-mono.text-xs Bindings: "order.*", "*.created.*", "#.vn"
          p.font-bold.mb-2 ‚úÖ Advantages:
          ul.list-disc.list-inside.text-sm.mb-2
            li Extremely flexible
            li Powerful pattern matching
            li Easy to extend (add new patterns)
            li One message ‚Üí multiple queues based on logic
          p.font-bold.mb-2 ‚ùå Disadvantages:
          ul.list-disc.list-inside.text-sm.mb-2
            li More complex than Direct/Fanout
            li Slower performance (pattern matching)
            li Easy to confuse with wildcards
        div
          p.font-bold.mb-2 üéØ When to use:
          ul.list-disc.list-inside.text-sm.mb-4
            li Event-driven microservices
            li Multi-tenant systems
            li Geographical routing
            li Hierarchical topics
          .bg-orange-50.p-4.rounded-lg
            p.font-bold.mb-2 Real example:
            p.text-sm E-commerce events:
            p.font-mono.text-xs.mt-2 "order.created.shop1.vn"
            p.font-mono.text-xs Bindings:
            p.font-mono.text-xs "order.created.*" ‚Üí inventory_service
            p.font-mono.text-xs "order.paid.#" ‚Üí accounting_service
            p.font-mono.text-xs "#.vn" ‚Üí vietnam_warehouse

    / Headers Exchange
    .bg-white.rounded-2xl.p-10.mb-10.border-2.border-purple-500.shadow-2xl.hover:shadow-3xl.transition-shadow
      h3.text-3xl.font-bold.mb-4.text-purple-600
        | 4. Headers Exchange
      .grid.grid-cols-1.md:grid-cols-2.gap-6.mb-6
        div
          p.text-lg.mb-4
            strong Mechanism:
            |  Match based on message headers
          .bg-white.p-4.rounded-lg.mb-4
            p.font-mono.text-sm.mb-2
              | Message headers: {format: "pdf", priority: "high"}
            p.text-gray-600.text-sm ‚Üì
            p.font-mono.text-sm Exchange matches headers with bindings
            p.text-gray-600.text-sm ‚Üì
            p.font-mono.text-sm Queue with matching headers receives message
          p.font-bold.mb-2 ‚úÖ Advantages:
          ul.list-disc.list-inside.text-sm.mb-2
            li Most complex routing logic
            li Not dependent on routing key
            li Multiple criteria matching
          p.font-bold.mb-2 ‚ùå Disadvantages:
          ul.list-disc.list-inside.text-sm.mb-2
            li Lowest performance
            li Complex configuration
            li Rarely used in practice
        div
          p.font-bold.mb-2 üéØ When to use:
          ul.list-disc.list-inside.text-sm.mb-4
            li Content-based routing
            li Complex business rules
            li Legacy system integration
          .bg-purple-50.p-4.rounded-lg
            p.font-bold.mb-2 Real example:
            p.text-sm File processing:
            p.font-mono.text-xs.mt-2
              | Headers: {format: "pdf", pages: 100}
            p.font-mono.text-xs Routes:
            p.font-mono.text-xs
              | {format: "pdf"} ‚Üí pdf_service
            p.font-mono.text-xs
              | {pages: >50} ‚Üí batch_processor

    .bg-white.rounded-2xl.p-10.mb-10.shadow-2xl
      h3.text-3xl.font-black.mb-8.text-center.text-gray-800 Compare 4 Exchange Types
      .overflow-x-auto
        table.w-full.bg-white.rounded-xl.shadow-lg
          thead.bg-gradient-to-r.from-orange-500.to-orange-600.text-white
            tr
              th.p-4.text-left Type
              th.p-4.text-center Performance
              th.p-4.text-center Complexity
              th.p-4.text-center Flexibility
              th.p-4.text-center Use Case
          tbody
            - exchange_comparison = [{ type: "Direct", perf: "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê", comp: "‚≠ê", flex: "‚≠ê", use: "Simple routing" }, { type: "Fanout", perf: "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê", comp: "‚≠ê", flex: "‚≠ê‚≠ê", use: "Broadcasting" }, { type: "Topic", perf: "‚≠ê‚≠ê‚≠ê", comp: "‚≠ê‚≠ê‚≠ê", flex: "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê", use: "Event-driven (Most popular)" }, { type: "Headers", perf: "‚≠ê‚≠ê", comp: "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê", flex: "‚≠ê‚≠ê‚≠ê‚≠ê", use: "Complex rules (Rarely used)" }]
            - exchange_comparison.each do |ex|
              tr.border-b.hover:bg-gray-50.transition-colors
                td.p-5.font-black.text-lg.text-gray-800 = ex[:type]
                td.p-5.text-center.text-xl = ex[:perf]
                td.p-5.text-center.text-xl = ex[:comp]
                td.p-5.text-center.text-xl = ex[:flex]
                td.p-5.text-center.text-base.font-medium.text-gray-700 = ex[:use]

      .bg-gradient-to-r.from-purple-100.to-purple-200.p-8.rounded-2xl.mt-8.text-center.shadow-xl.border-2.border-purple-300
        h4.mb-4.font-black.text-2xl.text-purple-800 üìä Recommendation:
        p.m-0.text-lg.font-semibold
          strong.text-purple-700 70% cases:
          |  Topic Exchange |
          strong.text-purple-700 20% cases:
          |  Fanout |
          strong.text-purple-700 10% cases:
          |  Direct |
          strong.text-purple-700 <1% cases:
          |  Headers

section.py-20.bg-gradient-to-b.from-base-200.to-base-100
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | üîÑ RabbitMQ Message Flow
    .bg-white.p-10.rounded-2xl.border-2.border-gray-300.shadow-2xl
      h3.text-3xl.font-black.mb-8.text-center.text-gray-800 Complete Message Lifecycle:
      .space-y-4
        - flow_steps = ["Producer creates message", "Publish to Exchange (with routing key)", "Exchange evaluates routing rules", "Message routed to Queue(s) based on bindings", "Queue persists message (if durable)", "Consumer fetches message from Queue", "Consumer processes message", "Consumer sends ACK back to RabbitMQ", "RabbitMQ removes message from Queue"]
        - flow_steps.each_with_index do |step, index|
          .flex.items-center.gap-6.mb-4
            .w-14.h-14.bg-gradient-to-br.from-orange-500.to-orange-600.text-white.rounded-full.flex.items-center.justify-center.font-black.text-xl.shadow-lg = index + 1
            span.text-xl.font-semibold.text-gray-800 = step
          - unless index == flow_steps.length - 1
            .text-center.text-orange-500.text-4xl.mb-2 ‚¨áÔ∏è

      .bg-gradient-to-br.from-blue-50.to-indigo-50.border-2.border-blue-500.p-8.rounded-xl.mt-10.shadow-xl
        h4.font-black.text-2xl.mb-6.text-blue-700 Key Points:
        ul.list-none.space-y-4
          li.p-4.bg-white.rounded-lg.shadow-sm
            strong.text-blue-700.font-bold At-least-once delivery:
            span.text-gray-700  Message not deleted until consumer ACKs
          li.p-4.bg-white.rounded-lg.shadow-sm
            strong.text-blue-700.font-bold Message Persistence:
            span.text-gray-700  Queue must be durable, message must be persistent
          li.p-4.bg-white.rounded-lg.shadow-sm
            strong.text-blue-700.font-bold Prefetch:
            span.text-gray-700  Limit number of messages consumer receives at once

section.py-20.bg-gradient-to-b.from-base-100.to-base-200
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | üõ°Ô∏è RabbitMQ Reliability Mechanisms

    .grid.grid-cols-1.md:grid-cols-2.lg:grid-cols-3.gap-8
      - reliability_features = [{ icon: "‚úÖ", title: "Acknowledgements (ACK/NACK/REJECT)", desc: "Manual ACK is safe - message kept until ACK. Auto ACK = message lost if consumer crashes." }, { icon: "üíæ", title: "Message Durability", desc: "Durable Queue + Persistent Messages = survive RabbitMQ restart" }, { icon: "üì©", title: "Publisher Confirms", desc: "Producer receives confirmation from RabbitMQ, ensures message was accepted" }, { icon: "üíÄ", title: "Dead Letter Exchange (DLX)", desc: "Queue for undeliverable messages (TTL expired, queue full, consumer reject)" }, { icon: "‚è∞", title: "Message TTL & Queue Length", desc: "TTL: Message expires after X seconds. Max Length: Queue limits number of messages" }, { icon: "üîÑ", title: "Clustering & Mirroring", desc: "Multiple RabbitMQ nodes, queue mirroring, high availability, no single point of failure" }]
      - reliability_features.each do |feature|
        .bg-white.border-2.border-orange-500.rounded-2xl.p-8.shadow-xl.hover:shadow-2xl.hover:-translate-y-1.transition-all
          .text-6xl.text-center.mb-4 = feature[:icon]
          h3.text-center.text-xl.mb-4.font-black.text-gray-800 = feature[:title]
          p.text-center.text-base.text-gray-700.leading-relaxed.m-0 = feature[:desc]

section.py-20.bg-gradient-to-b.from-base-200.to-base-100
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | üéØ RabbitMQ Use Cases & Patterns

    .grid.grid-cols-1.md:grid-cols-2.lg:grid-cols-3.gap-6.mb-8
      - patterns = [{ name: "Work Queue", desc: "Multiple workers compete for jobs, load distribution", use: "Background jobs, task processing" }, { name: "Pub/Sub", desc: "Broadcast messages to all subscribers", use: "Notifications, logging, cache invalidation" }, { name: "Routing", desc: "Selective message delivery based on criteria", use: "Log levels, priority routing" }, { name: "Topics", desc: "Pattern-based routing", use: "Event-driven microservices" }, { name: "RPC (Request/Reply)", desc: "Synchronous-like behavior over async system", use: "Remote procedure calls" }, { name: "Priority Queues", desc: "High priority messages processed first", use: "Critical vs normal tasks" }]
      - patterns.each do |pattern|
        .bg-white.p-8.rounded-2xl.border-2.border-gray-300.shadow-xl.hover:shadow-2xl.hover:-translate-y-1.transition-all
          h3.text-2xl.font-black.mb-3.text-orange-600 = pattern[:name]
          p.text-base.text-gray-700.mb-4.font-medium = pattern[:desc]
          p.text-sm.text-gray-600.bg-orange-50.px-4.py-2.rounded-lg
            strong.font-bold Use:
            = " #{pattern[:use]}"

    .bg-gradient-to-br.from-green-50.to-emerald-50.border-2.border-green-500.p-8.rounded-2xl.shadow-xl
      h4.font-black.text-2xl.mb-6.text-green-700 Common Use Cases:
      .grid.grid-cols-2.md:grid-cols-4.gap-4.text-base
        - use_cases = ["Microservices communication", "Event-driven architecture", "Decoupling services", "Load balancing", "Async processing", "Data pipeline", "Message broadcasting", "Priority task handling"]
        - use_cases.each do |use_case|
          .bg-white.px-4.py-3.rounded-lg.shadow-sm.font-medium.text-gray-700 ‚Ä¢ #{use_case}

section.py-20.bg-base-100
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | ‚ö° Sidekiq (Redis Queue) Overview

    .grid.grid-cols-1.md:grid-cols-2.gap-8.mb-8
      .bg-white.p-10.rounded-2xl.border-2.border-green-300.shadow-2xl
        h3.text-3xl.mb-6.border-b-4.border-green-500.pb-4.font-black.text-gray-800 What is Sidekiq?
        ul.list-none.p-0.space-y-3
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium Background job processor for Ruby/Rails
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium Uses Redis as message queue backend
          li.py-3.px-4.bg-green-50.rounded-lg.text-lg.font-medium Thread-based architecture

      .bg-white.p-10.rounded-2xl.border-2.border-green-300.shadow-2xl
        h3.text-3xl.mb-6.border-b-4.border-green-500.pb-4.font-black.text-gray-800 Highlights
        ul.list-none.p-0.space-y-2
          li.py-2.px-4.rounded-lg.text-base.font-medium ‚úÖ Extremely fast (100K+ jobs/sec)
          li.py-2.px-4.rounded-lg.text-base.font-medium ‚úÖ Simple setup
          li.py-2.px-4.rounded-lg.text-base.font-medium ‚úÖ Beautiful Web UI
          li.py-2.px-4.rounded-lg.text-base.font-medium ‚úÖ Best Rails integration
          li.py-2.px-4.rounded-lg.text-base.font-medium ‚úÖ Automatic retry
          li.py-2.px-4.bg-red-50.rounded-lg.text-base.font-medium ‚ùå No advanced routing
          li.py-2.px-4.bg-yellow-50.rounded-lg.text-base.font-medium ‚ö†Ô∏è Persistence depends on Redis
          li.py-2.px-4.rounded-lg.text-base.font-medium ‚úÖ Faster for simple jobs
          li.py-2.px-4.rounded-lg.text-base.font-medium ‚úÖ Easier setup & maintenance

section.py-20.bg-gradient-to-b.from-base-200.to-base-100
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | ‚öñÔ∏è Detailed Comparison: RabbitMQ vs Sidekiq

    .space-y-8
      - comparison_categories = [{ title: "Architecture & Protocol", items: [{ aspect: "Type", rabbitmq: "Message Broker (standalone)", sidekiq: "Background job library" }, { aspect: "Protocol", rabbitmq: "AMQP (standardized)", sidekiq: "Redis protocol" }, { aspect: "Storage", rabbitmq: "Disk-based + Memory", sidekiq: "In-memory (RAM only)" }, { aspect: "Language", rabbitmq: "Erlang (highly concurrent)", sidekiq: "Ruby + Redis" }] }, { title: "Performance & Scalability", items: [{ aspect: "Throughput", rabbitmq: "~20,000 msg/s", sidekiq: "~100,000+ jobs/s", winner: "sidekiq" }, { aspect: "Latency", rabbitmq: "~50ms (p99)", sidekiq: "~10ms (p99)", winner: "sidekiq" }, { aspect: "Memory Usage", rabbitmq: "Medium-High", sidekiq: "Low (thread-based)", winner: "sidekiq" }, { aspect: "Scaling", rabbitmq: "Horizontal (cluster)", sidekiq: "Horizontal (multiple processes)", winner: "tie" }] }, { title: "Routing & Flexibility", items: [{ aspect: "Routing Types", rabbitmq: "4 exchange types", sidekiq: "Queue names only", winner: "rabbitmq" }, { aspect: "Pattern Matching", rabbitmq: "‚úÖ Wildcards (*, #)", sidekiq: "‚ùå None", winner: "rabbitmq" }, { aspect: "Broadcast", rabbitmq: "‚úÖ Fanout exchange", sidekiq: "‚ùå Manual implementation", winner: "rabbitmq" }, { aspect: "Topic-based", rabbitmq: "‚úÖ Topic exchange", sidekiq: "‚ùå Not supported", winner: "rabbitmq" }] }, { title: "Reliability & Guarantees", items: [{ aspect: "Persistence", rabbitmq: "‚úÖ Disk-based, durable", sidekiq: "‚ö†Ô∏è Optional (RDB/AOF)", winner: "rabbitmq" }, { aspect: "Publisher Confirms", rabbitmq: "‚úÖ Built-in", sidekiq: "‚ùå None", winner: "rabbitmq" }, { aspect: "Message TTL", rabbitmq: "‚úÖ Per-message or queue", sidekiq: "‚ö†Ô∏è Manual implementation", winner: "rabbitmq" }, { aspect: "Data Loss Risk", rabbitmq: "Very Low", sidekiq: "Medium (if Redis crashes)", winner: "rabbitmq" }] }, { title: "Development & Integration", items: [{ aspect: "Setup Complexity", rabbitmq: "Medium-High", sidekiq: "Very Low", winner: "sidekiq" }, { aspect: "Learning Curve", rabbitmq: "Steep", sidekiq: "Gentle", winner: "sidekiq" }, { aspect: "Rails Integration", rabbitmq: "‚ö†Ô∏è Needs Sneakers/Bunny", sidekiq: "‚úÖ Native, seamless", winner: "sidekiq" }, { aspect: "Multi-language", rabbitmq: "‚úÖ All languages", sidekiq: "‚ùå Ruby only", winner: "rabbitmq" }] }, { title: "Cost & Infrastructure", items: [{ aspect: "RAM Required", rabbitmq: "2-4GB base", sidekiq: "512MB - 2GB", winner: "sidekiq" }, { aspect: "Monthly Cost", rabbitmq: "~$50-400 (cloud)", sidekiq: "~$15-200 (cloud)", winner: "sidekiq" }, { aspect: "Maintenance", rabbitmq: "Medium effort", sidekiq: "Low effort", winner: "sidekiq" }, { aspect: "DevOps Complexity", rabbitmq: "Higher", sidekiq: "Lower", winner: "sidekiq" }] }]
      - comparison_categories.each do |category|
        .bg-white.rounded-2xl.p-8.border-2.border-gray-300.shadow-2xl.mb-8
          h3.text-3xl.font-black.mb-6.text-orange-600 = category[:title]
          .overflow-x-auto
            table.w-full.shadow-lg
              thead.bg-gradient-to-r.from-orange-500.to-orange-600.text-white
                tr
                  th.p-3.text-left Aspect
                  th.p-3.text-left RabbitMQ
                  th.p-3.text-left Sidekiq
              tbody
                - category[:items].each do |item|
                  tr.border-b.hover:bg-gray-50.transition-colors
                    td.p-4.font-bold.text-lg.text-gray-800 = item[:aspect]
                    td.p-4.text-base class="#{'bg-green-100 font-semibold' if item[:winner] == 'rabbitmq'}"
                      = item[:rabbitmq]
                      - if item[:winner] == "rabbitmq"
                        span.ml-2.text-green-600.font-bold.text-xl üèÜ
                    td.p-4.text-base class="#{'bg-green-100 font-semibold' if item[:winner] == 'sidekiq'}"
                      = item[:sidekiq]
                      - if item[:winner] == "sidekiq"
                        span.ml-2.text-green-600.font-bold.text-xl üèÜ

    .bg-gradient-to-r.from-green-100.to-green-200.p-10.rounded-2xl.mt-10.text-center.shadow-2xl.border-2.border-green-400
      h3.text-4xl.font-black.mb-6.text-green-800 Summary Score
      .grid.grid-cols-2.md:grid-cols-5.gap-6.mb-6
        - scores = [{ cat: "Performance", rabbitmq: "4/5", sidekiq: "5/5" }, { cat: "Reliability", rabbitmq: "5/5", sidekiq: "3/5" }, { cat: "Flexibility", rabbitmq: "5/5", sidekiq: "2/5" }, { cat: "Ease of Use", rabbitmq: "3/5", sidekiq: "5/5" }, { cat: "Cost", rabbitmq: "3/5", sidekiq: "5/5" }]
        - scores.each do |score|
          .bg-white.p-6.rounded-xl.shadow-lg
            .font-black.text-base.mb-3.text-gray-800 = score[:cat]
            .text-orange-600.font-black.text-xl.mb-1 RabbitMQ: #{score[:rabbitmq]}
            .text-green-600.font-black.text-xl Sidekiq: #{score[:sidekiq]}
      .bg-white.p-6.rounded-xl.inline-block.shadow-xl.mb-6
        .font-black.text-2xl
          strong.text-gray-800 TOTAL:
          span.text-orange-600.ml-2 RabbitMQ: 20/25
          span.text-gray-400.mx-2 |
          span.text-green-600 Sidekiq: 20/25
      p.mt-6.font-bold.text-xl.text-gray-800 Conclusion: No absolute winner - Depends on use case!

section.py-20.bg-base-100
  .container.mx-auto.px-4
    h2.section-title.text-5xl.font-black.text-center.mb-12.text-orange-600.tracking-tight
      | üéØ When to Use What?

    .bg-white.p-10.rounded-2xl.border-2.border-gray-300.mb-10.shadow-2xl
      h3.mb-8.text-3xl.font-black.text-gray-800 Decision Matrix:
      .overflow-x-auto
        table.w-full.bg-white.rounded-xl.shadow-lg
          thead.bg-gradient-to-r.from-orange-500.to-orange-600.text-white
            tr
              th.p-4.text-left Requirement
              th.p-4.text-left Recommendation
              th.p-4.text-left Reason
          tbody
            - decisions = [{ req: "Rails monolith app", rec: "Sidekiq", reason: "Simple, fast, Rails-optimized" }, { req: "Microservices (2+ services)", rec: "RabbitMQ", reason: "Inter-service communication" }, { req: "Multi-language environment", rec: "RabbitMQ", reason: "Language-agnostic" }, { req: "Complex routing needs", rec: "RabbitMQ", reason: "Topic/Fanout exchanges" }, { req: "Simple background jobs", rec: "Sidekiq", reason: "Overkill to use RabbitMQ" }, { req: "Mission-critical data", rec: "RabbitMQ", reason: "Better persistence" }, { req: "Budget constraints", rec: "Sidekiq", reason: "Cheaper infrastructure" }, { req: "Need pattern matching", rec: "RabbitMQ", reason: "Wildcards support" }, { req: "Event-driven architecture", rec: "RabbitMQ", reason: "Pub/Sub patterns" }, { req: "Quick MVP", rec: "Sidekiq", reason: "Faster setup" }, { req: "Enterprise scale", rec: "RabbitMQ", reason: "Better for large systems" }]
            - decisions.each do |decision|
              tr.border-b.hover:bg-gray-50.transition-colors
                td.p-5.font-bold.text-lg.text-gray-800 = decision[:req]
                td.p-5.text-green-600.font-black.text-xl = decision[:rec]
                td.p-5.text-base.text-gray-700 = decision[:reason]

    .bg-gradient-to-r.from-green-100.to-green-200.p-10.rounded-2xl.mb-10.shadow-2xl.border-2.border-green-400
      h3.text-4xl.font-black.mb-6.text-center.text-green-800 ‚≠ê Pattern 3: Hybrid (Recommended)
      .bg-white.p-8.rounded-xl.mb-6.shadow-xl
        p.text-lg.font-bold.mb-2 Best for: Growing applications
        .font-mono.text-sm.mt-4
          p Rails App
          p.ml-4 ‚îú‚îÄ Sidekiq: Internal background jobs
          p.ml-8 ‚îú‚îÄ Send emails
          p.ml-8 ‚îú‚îÄ Process uploads
          p.ml-8 ‚îî‚îÄ Generate reports
          p.ml-4 ‚îî‚îÄ RabbitMQ: External communication
          p.ml-8 ‚îú‚îÄ Publish events to other services
          p.ml-8 ‚îú‚îÄ Receive events from services
          p.ml-8 ‚îî‚îÄ Complex routing patterns
      p.mt-4.font-bold Example: Shopify, GitLab, large platforms

    .bg-gradient-to-r.from-purple-100.to-purple-200.p-6.rounded-xl
      h4.mb-4.font-bold.text-xl Growth Path:
      - growth_stages = [{ stage: "Stage 1: MVP / Small App", use: "Sidekiq only", why: "Simple, fast to build" }, { stage: "Stage 2: Growing App", use: "Sidekiq + Redis", why: "Add more workers, queues" }, { stage: "Stage 3: Multiple Services Emerge", use: "Add RabbitMQ for service communication", why: "Keep Sidekiq for internal jobs" }, { stage: "Stage 4: Microservices Architecture", use: "Primary: RabbitMQ for all services", why: "Optional: Sidekiq in Rails services" }]
      - growth_stages.each do |stage|
        .bg-white.p-4.rounded-lg.mb-3
          .font-bold.text-orange-600.mb-1 = stage[:stage]
          .text-sm
            strong Use:
            = " #{stage[:use]}"
          .text-sm.text-gray-600
            strong Why:
            = " #{stage[:why]}"


section.py-24.bg-gradient-to-br.from-purple-700.via-purple-600.to-teal-600.relative.overflow-hidden
  .absolute.inset-0.bg-black.opacity-20
  .container.mx-auto.px-4.text-center.relative.z-10
    .text-9xl.mb-6.animate-bounce üôè
    h2.text-6xl.md:text-7xl.font-black.mb-6.text-white.drop-shadow-2xl Thank You!

    .bg-white.bg-opacity-20.backdrop-blur-md.p-8.rounded-2xl.max-w-2xl.mx-auto.shadow-2xl.border-2.border-white.border-opacity-30
      h3.text-white.mb-6.text-3xl.font-black üîó Useful Resources
      .space-y-3
        p.text-xl.text-white.font-semibold.my-3 üêá rabbitmq.com
        p.text-xl.text-white.font-semibold.my-3 ‚ö° sidekiq.org
        p.text-xl.text-white.font-semibold.my-3 üìö amqp.org
